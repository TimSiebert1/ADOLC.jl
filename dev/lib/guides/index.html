<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guides · ADOLC.jl</title><meta name="title" content="Guides · ADOLC.jl"/><meta property="og:title" content="Guides · ADOLC.jl"/><meta property="twitter:title" content="Guides · ADOLC.jl"/><meta name="description" content="Documentation for ADOLC.jl."/><meta property="og:description" content="Documentation for ADOLC.jl."/><meta property="twitter:description" content="Documentation for ADOLC.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ADOLC.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li class="is-active"><a class="tocitem" href>Guides</a><ul class="internal"><li><a class="tocitem" href="#Working-with-C-Memory"><span>Working with C++ Memory</span></a></li><li><a class="tocitem" href="#Seed-Matrix"><span>Seed-Matrix</span></a></li></ul></li><li><a class="tocitem" href="../derivative_modes/">Derivative Modes</a></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../wrapped_fcts/">Wrapped Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Guides</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Guides</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="github.com/TimSiebert1/ADOLC.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Working-with-C-Memory"><a class="docs-heading-anchor" href="#Working-with-C-Memory">Working with C++ Memory</a><a id="Working-with-C-Memory-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-C-Memory" title="Permalink"></a></h2><p>ADOLC.jl is a wrapper of the C/C++ library <a href="https://github.com/coin-or/ADOL-C">ADOL-C</a>. Wrapper means data from Julia is passed to C++, and calls to functions in Julia trigger C++ function calls to get output data in Julia. The communication between Julia and <a href="https://github.com/coin-or/ADOL-C">ADOL-C</a> is handled by <a href="https://github.com/JuliaInterop/CxxWrap.jl">CxxWrap.jl</a>, which, for example, allows to pass a <code>Cint</code> from Julia into a <code>int</code> in C++ automatically. Most functions  of <a href="https://github.com/coin-or/ADOL-C">ADOL-C</a> modify pre-allocated memory declared as <code>double*</code>, <code>double**</code>, or <code>double***</code> to store a functions&#39; results. Two apparent options exist for providing the pre-allocated data to the C++ functions called from Julia. The first option would be to write wrappers in C++, which allocate the memory every time before the actual <a href="https://github.com/coin-or/ADOL-C">ADOL-C</a> function call. This would cease control over the allocations from Julia, but it would be easier to work with on the Julia side, and the C++ side would have full control over the memory. The second option is to allocate  C++-owned data from julia by calling <a href="https://github.com/coin-or/ADOL-C">ADOL-C</a>&#39;s allocation methods from Julia, to pass these data to <a href="https://github.com/coin-or/ADOL-C">ADOL-C</a>&#39;s functions mutating the allocated data, and to access the mutated values from Julia. The second option allows more control over the data, but a user has to be aware of some critical aspects: </p><ol><li>C++ owned memory is not automatically garbage collected and can lead to memory leaks quickly if not released. For example, having a Julia function that allocates a <code>double**</code> in C++ and binds this pointer to a variable in a Julia would release the  bound variable when going out of the functions&#39; scope, but the C++ memory would still be  there, you just cannot access it anymore.</li><li>There is no out-of-bounds error checking to prevent accessing or setting of  data outside of the allocated area, which may lead to segmentation faults and program crashes.</li><li>If you want to do computations with the C++ data, you either have to copy these to a corresponding Julia type or write access  methods to work with the C++  allocated data.</li></ol><p>ADOLC.jl implements the second option. The critical aspects can still be avoided using the driver <a href="../reference/#ADOLC.derivative"><code>derivative</code></a>, which handles the C++ allocated memory for you. However, the best performance is obtained when using <a href="../reference/#ADOLC.derivative!"><code>derivative!</code></a>. For first- and second-order derivative computations, the <a href="../reference/#ADOLC.derivative!"><code>derivative!</code></a> driver requires  a pre-allocated container of C++ allocated data. The allocation is done using <a href="../reference/#ADOLC.allocator"><code>allocator</code></a>. This function allocates C++ memory for your specific case (i.e., for the problem-specific parameters <code>m</code>, <code>n</code>, <code>mode</code>, <code>num_dir</code>, <code>num_weights</code>). Thus, the computation of the derivative just  utilizes <a href="../reference/#ADOLC.derivative"><code>derivative</code></a>. For example:</p><pre><code class="language-julia hljs">using ADOLC
f(x) = (x[1] - x[2])^2
x = [3.0, 7.5]
dir = [1/3, 1/7]
m = 1
n = 2
mode = :jac_vec
num_dir = size(dir, 2)[1]
num_weights = 0
cxx_res = allocator(m, n, mode, num_dir, num_weights)
derivative!(cxx_res, f, m, n, x, mode, dir=dir)
deallocator!(cxx_res, m, mode)</code></pre><p>The first critical point is tackled using the <a href="../reference/#ADOLC.deallocator!"><code>deallocator!</code></a> function, which handles the release of the C++ memory. Of course, one wants to conduct computations with <code>cxx_res</code>. The recommended way to do so is to pre-allocate a corresponding Julia container (<code>Vector{Float64}</code>, <code>Matrix{Float64}</code> or <code>Array{Float64, 3}</code>) obtained from <a href="../reference/#ADOLC.jl_allocator"><code>jl_allocator</code></a> and copy the data from <code>cxx_res</code> the Julia storage <code>jl_res</code> by leveraging <a href="../reference/#ADOLC.array_types.cxx_res_to_jl_res!"><code>cxx_res_to_jl_res!</code></a>:</p><pre><code class="language-julia hljs">using ADOLC
f(x) = (x[1] - x[2])^2
x = [3.0, 7.5]
dir = [1/3, 1/7]
m = 1
n = 2
mode = :jac_vec
num_dir = size(dir, 2)[1]
num_weights = 0

# pre-allocation
jl_res = jl_allocator(m, n, mode, num_dir, num_weights)
cxx_res = allocator(m, n, mode, num_dir, num_weights)

derivative!(cxx_res, f, m, n, x, mode, dir=dir)

# conversion
cxx_res_to_jl_res!(jl_res, cxx_res, m, n, mode, num_dir, num_weights)

# do computations ....


deallocator!(cxx_res, m, mode)</code></pre><p>Since you work with Julia data, the procedure above avoids the second and third points of the critical aspects but includes an additional allocation.  </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>cxx_res</code> still stores a pointer. The corresponding memory is destroyed, but <code>cxx_res</code> is managed by Julia&#39;s garbage collector. Do not use it.</p></div></div><p>In the future, the plan is to implement a struct that combines the Julia and C++ arrays with a finalizer that enables Julia&#39;s garbage collector to manage the C++ memory. </p><h2 id="Seed-Matrix"><a class="docs-heading-anchor" href="#Seed-Matrix">Seed-Matrix</a><a id="Seed-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Seed-Matrix" title="Permalink"></a></h2><p>This guide is related to the <a href="../derivative_modes/#Higher-Order">higher-order</a> derivative computation with  <a href="../reference/#ADOLC.derivative"><code>derivative</code></a> or <a href="../reference/#ADOLC.derivative!"><code>derivative!</code></a>. Internally, the drivers are based on the propagation of univariate Taylor polynomials [<a href="../../#griewank_evaluating_1999">1</a>]. The underlying method leverages a <code>seed</code> matrix <span>$S\in \mathbb{R}^{n \times p}$</span> to compute mixed-partials of arbitrary order for a function <span>$f:\mathbb{R}^n \to \mathbb{R}^m$</span> in the form: </p><p class="math-container">\[    \frac{\partial^k f(x + Sz)}{\partial^k z}\big|_{z=0} \]</p><p>for some <span>$z \in \mathbb{R}^p$</span>. Usually, <span>$S$</span> is the <em>identity</em> or the <em>partial identity</em> (see <a href="../reference/#ADOLC.create_partial_cxx_identity"><code>create_partial_cxx_identity</code></a>), which is also the case, when no <code>seed</code> is passed to the driver. To switch between both identity options the flag <code>id_seed</code> can be used. In the case of identity, the formula above boils down to </p><p class="math-container">\[    \frac{\partial^k f(x + Sz)}{\partial^k z}\big|_{z=0}= \frac{\partial^k f(x)}{\partial^k x}.\]</p><p>Moreover, the partial identity results in the same but is more efficient. Leveraging the partial identity ensures that only the derivatives of the requested derivative directions are computed, and this is explained briefly in the following paragraph.   </p><p>Assume we want to compute the derivatives specified in the <a href="../derivative_modes/#Partial-Format">Partial-Format</a>: [[4, 0, 0, 3], [2, 0, 0, 4], [1, 0, 0, 1]].   Obviously, none of the derivatives includes <span>$x_2$</span> and <span>$x_3$</span>. To avoid unnecessary computations (i.e., the propagation of unnecessary univariate Polynomials), the partial identity is created, stacking only those canonical basis vectors that are related to the requested derivative directions. In our case, the partial identity looks like this:  </p><p class="math-container">\[\left[
    \begin{matrix}
    1 &amp; 0 \\
    0 &amp; 0 \\
    0 &amp; 0 \\
    0 &amp; 1 
    \end{matrix}
 \right].\]</p><p>As you can see, the directions are reduced from four to two. In general, the number of required univariate Polynomial propagations to compute all mixed-partials up to degree <span>$d$</span> of for <span>$f$</span> is <span>$\left( \begin{matrix} n - 1 + d \\ d \end{matrix} \right)$</span>. Leveraging the <code>seed</code> <span>$S$</span> reduces this number to <span>$\left( \begin{matrix} p - 1 + d \\ d \end{matrix} \right)$</span>, where <span>$p$</span> is often much smaller than <span>$n$</span>. In addition, <span>$S$</span> can be used as a subspace projection. For example, if <span>$S=[1, \dots, 1]^T$</span>, you could compute the sum of the different univariate Taylor coefficients:</p><pre><code class="language-julia hljs">using ADOLC
f(x) = x[1]^3*x[2]^2 - x[2]^3
x = [1.0, 1.0]
partials = [[1], [2], [3]]
seed = [[1.0, 1.0];;]
res = derivative(f, x, partials, seed)

# output

1×3 Matrix{Float64}:
 2.0  14.0  54.0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../derivative_modes/">Derivative Modes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 21 June 2024 10:01">Friday 21 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
