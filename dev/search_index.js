var documenterSearchIndex = {"docs":
[{"location":"lib/reference/#API-reference","page":"Reference","title":"API reference","text":"","category":"section"},{"location":"lib/reference/","page":"Reference","title":"Reference","text":"ADOLC.derivative\nADOLC.tensor_address\nADOLC.partial_to_adolc_format\nADOLC.partial_to_adolc_format!\nADOLC.create_cxx_identity\nADOLC.create_partial_cxx_identity\nADOLC.seed_idxs_partial_format\nADOLC.seed_idxs_adolc_format\nADOLC.partial_format_to_seed_space\nADOLC.adolc_format_to_seed_space","category":"page"},{"location":"lib/reference/#ADOLC.derivative","page":"Reference","title":"ADOLC.derivative","text":"derivative(\n    f::Function,\n    m::Integer,\n    n::Integer,\n    x::Union{Float64,Vector{Float64}},\n    mode::Symbol;\n    dir::Union{Vector{Float64},Matrix{Float64}}=Vector{Float64}(),\n    weights::Union{Vector{Float64},Matrix{Float64}}=Vector{Float64}(),\n    tape_id::Integer=0,\n    reuse_tape::Bool=false,\n)\n\nA variant of the derivative driver, which can be used to compute first-order and second-order  derivatives, as well as the abs-normal-form  of the given function f with output dimension m, input dimension n  at the point x. The mode has to be choosen from derivative modes. The corresponding formulas define weights (left multiplier) and dir (right multiplier). Most modes leverage a tape, which has the identifier tape_id. If there is already a valid  tape for the function f at the selected point x use reuse_tape=true and set the tape_id accordingly to avoid the re-creation of the tape.\n\nExamples:\n\nFirst-Order:\n\nf(x) = sin(x)\nres = derivative(f, 1, 1, float(Ï€), :jac)\n\n# output\n\n1-element Vector{Float64}:\n -1.0\n\nSecond-Order:\n\nf(x) = [x[1]*x[2]^2, x[1]^2*x[3]^3]\nx = [1.0, 2.0, -1.0]\ndir = [1.0, 0.0, 0.0]\nweights = [1.0, 1.0]\nres = derivative(f, 2, 3, x, :vec_hess_vec, dir=dir, weights=weights)\n\n# output\n\n3-element Vector{Float64}:\n -2.0\n  4.0\n  6.0\n\nAbs-Normal-Form:\n\nf(x) = max(x[1]*x[2], x[1]^2)\nx = [1.0, 1.0]\nres = derivative(f, 1, 2, x, :abs_normal)\n\n# output\n\nAbsNormalForm(0, 1, 2, 1, [1.0, 1.0], [1.0], [0.0], [0.0], [1.0], [1.5 0.5], [0.5;;], [1.0 -1.0], [0.0;;])\n\n\n\n\n\nderivative(\n    f::Function,\n    m::Integer,\n    n::Integer,\n    x::Union{Float64,Vector{Float64}},\n    partials::Vector{Vector{Int64}};\n    tape_id::Int64=0,\n    reuse_tape::Bool=false,\n    id_seed::Bool=false,\n    adolc_format::Bool=false,\n)\n\nA variant of the derivative driver, which can be used to compute higher-order derivatives of the function f with output  dimension m, input dimension n at the point x. The derivatives are specified as mixed-partials in the partials vector. To define the partial-derivatives use either the Partial-Format or the ADOLC-Format and set adolc_format accordingly. The flag id_seed is used to specify the method for seed-matrix generation. The underlying method leverages a tape, which has the identifier tape_id. If there is already a valid  tape for the function f at the selected point x use reuse_tape=true and set the tape_id accordingly to avoid the re-creation of the tape.\n\n\n\n\n\nderivative(\n    f::Function,\n    m::Int64,\n    n::Int64,\n    x::Union{Float64,Vector{Float64}},\n    partials::Vector{Vector{Int64}},\n    seed::Matrix{Float64};\n    tape_id::Int64=0,\n    reuse_tape::Bool=false,\n    adolc_format::Bool=false,\n)\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.tensor_address","page":"Reference","title":"ADOLC.tensor_address","text":"tensor_address(degree::I, adolc_partial::Vector{I}) where I <: Integer\ntensor_address(degree::Cint, adolc_partial::Vector{I}) where I <: Integer\ntensor_address(degree::I, adolc_partial::Vector{Cint}) where I <: Integer\ntensor_address(degree::Cint, adolc_partial::Vector{Cint})\n\nGenerates the index (address) of the mixed-partial specified by adolc_partial in an higher-order derivative tensor of derivative order degree.\n\nnote: Note\nThe partial has to be in ADOLC-Format.\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.partial_to_adolc_format","page":"Reference","title":"ADOLC.partial_to_adolc_format","text":"partial_to_adolc_format(partial::Vector{I_1}, degree::I_2) where {I_1<:Integer, I_2<:Integer}\n\nTransforms a given partial to the ADOLC-Format. \n\nnote: Note\npartial is required to be in the Partial-format\n\nExample:\n\n\npartial = [1, 0, 4]\ndegree = sum(partial)\npartial_to_adolc_format(partial, degree)\n\n# output\n\n5-element Vector{Int32}:\n 3\n 3\n 3\n 3\n 1\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.partial_to_adolc_format!","page":"Reference","title":"ADOLC.partial_to_adolc_format!","text":"partial_to_adolc_format!(res::Vector{Cint}, partial::Vector{I_1}, degree::I_2) where {I_1<:Integer, I_2<:Integer}\npartial_to_adolc_format!(res::Vector{Cint}, partial::Vector{Cint}, degree::I) where I <: Integer\n\nVariant of partial_to_adolc_format that writes the result to res.\n\nExample:\n\npartial = [1, 3, 2, 0]\ndegree = sum(partial)\nres = zeros(Int32, degree)\npartial_to_adolc_format!(res, partial, degree)\n\n# output\n\n6-element Vector{Int32}:\n 3\n 3\n 2\n 2\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.create_cxx_identity","page":"Reference","title":"ADOLC.create_cxx_identity","text":"create_cxx_identity(n::I_1, m::I_2) where {I_1 <: Integer, I_2 <: Integer}\n\nCreates a identity matrix of shape (n, m) of type CxxPtr{CxxPtr{Float64}} (wrapper of C++'s double**).\n\nExample\n\nid = create_cxx_identity(2, 4)\nfor i in 1:2\n    for j in 1:4\n        print(id[i, j], \" \")\n    end\n    println(\"\")\nend\n\n# output\n\n1.0 0.0 0.0 0.0 \n0.0 1.0 0.0 0.0\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.create_partial_cxx_identity","page":"Reference","title":"ADOLC.create_partial_cxx_identity","text":"create_partial_cxx_identity(n::I_1, idxs::Vector{I_2}) where {I_1 <: Integer, I_2 <: Integer}\n\nCreates a matrix of shape (n, length(idxs)) of type CxxPtr{CxxPtr{Float64}} (wrapper of C++'s double**). The columns are canonical basis vectors corresponding to the entries of idxs. The order of the basis vectors is defined by the order of the indices in idxs.\n\nwarning: Warning\nThe number of rows n must be smaller than the maximal index of idxs!\n\nwarning: Warning\nThe values of idxs must be non-negative!\n\nExamples\n\nn = 4\nidxs = [1, 3]\nid = create_partial_cxx_identity(n, idxs)\nfor i in 1:4\n    for j in 1:length(idxs)\n        print(id[i, j], \" \")\n    end\n    println(\"\")\nend\n\n# output\n\n1.0 0.0 \n0.0 0.0\n0.0 1.0\n0.0 0.0\n\nThe order in idxs defines the order of the basis vectors.\n\nn = 3\nidxs = [3, 0, 1]\nid = create_partial_cxx_identity(n, idxs)\nfor i in 1:3\n    for j in 1:length(idxs)\n        print(id[i, j], \" \")\n    end\n    println(\"\")\nend\n\n# output\n\n0.0 0.0 1.0\n0.0 0.0 0.0\n1.0 0.0 0.0\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.seed_idxs_partial_format","page":"Reference","title":"ADOLC.seed_idxs_partial_format","text":"seed_idxs_partial_format(partials::Vector{Vector{I}}) where I <: Integer\n\nExtracts the actually required derivative directions of partials and returns them  ascendet sorted. \n\nnote: Note\npartials has to be in Partial-Format.\n\nExample\n\n\npartials = [[1, 0, 0, 0, 3], [1, 0, 1, 0, 0], [0, 0, 3, 0, 0]]\nseed_idxs_partial_format(partials)\n\n# output\n\n3-element Vector{Int64}:\n 1\n 3\n 5\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.seed_idxs_adolc_format","page":"Reference","title":"ADOLC.seed_idxs_adolc_format","text":"seed_idxs_adolc_format(partials::Vector{Vector{I}}) where I <: Integer\n\nExtracts the actually required derivative directions of partials and returns them  ascendet sorted. \n\nnote: Note\npartials has to be in ADOLC-Format.\n\nExample\n\n\npartials = [[5, 5, 5, 1], [3, 1, 0, 0], [3, 3, 3, 0]]\nseed_idxs_adolc_format(partials)\n\n# output\n\n3-element Vector{Int64}:\n 1\n 3\n 5\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.partial_format_to_seed_space","page":"Reference","title":"ADOLC.partial_format_to_seed_space","text":"partial_format_to_seed_space(partials::Vector{Vector{I_1}}, seed_idxs::Vector{I_2}) where {I_1 <: Integer, I_2 <: Integer}\npartial_format_to_seed_space(partials::Vector{Vector{I}}) where I <: Integer\n\nConverts partials in Partial-Format to partials of the same format but with (possible) reduced number  of derivatives directions. The seed_idxs is expected to store the result of seed_idxs_partial_format(seed_idxs). Without seed_idxs the function first calls seed_idxs_partial_format(seed_idxs) to get the indices.\n\nExamples\n\n\npartials = [[0, 1, 1], [0, 2, 0]]\nseed_idxs = seed_idxs_partial_format(partials)\npartial_format_to_seed_space(partials, seed_idxs)\n\n# output\n\n2-element Vector{Vector{Int64}}:\n [1, 1]\n [2, 0]\n\nWithout seed_idxs\n\n\npartials = [[0, 1, 1], [0, 2, 0]]\npartial_format_to_seed_space(partials)\n\n# output\n\n2-element Vector{Vector{Int64}}:\n [1, 1]\n [2, 0]\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.adolc_format_to_seed_space","page":"Reference","title":"ADOLC.adolc_format_to_seed_space","text":"adolc_format_to_seed_space(partials::Vector{Vector{I_1}}, seed_idxs::Vector{I_2}) where {I_1 <: Integer, I_2 <: Integer}\nadolc_format_to_seed_space(partials::Vector{Vector{I}}) where I <: Integer\n\nSame as partial_format_to_seed_space but with ADOLC-Format.\n\nExamples\n\n\npartials = [[3, 2], [2, 2]]\nseed_idxs = seed_idxs_adolc_format(partials)\nadolc_format_to_seed_space(partials, seed_idxs)\n\n# output\n\n2-element Vector{Vector{Int64}}:\n [2, 1]\n [1, 1]\n\nWithout seed_idxs\n\n\npartials = [[3, 2], [2, 2]]\nseed_idxs = seed_idxs_adolc_format(partials)\nadolc_format_to_seed_space(partials, seed_idxs)\n\n# output\n\n2-element Vector{Vector{Int64}}:\n [2, 1]\n [1, 1]\n\n\n\n\n\n","category":"function"},{"location":"#ADOLC.jl","page":"Home","title":"ADOLC.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia wrapper of the algorithmic differentiation package ADOL-C","category":"page"},{"location":"#Derivative-Modes","page":"Home","title":"Derivative Modes","text":"","category":"section"},{"location":"#First-Order","page":"Home","title":"First-Order","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mode Formula\njac Df(x)\njac_vec Df(x)dotv\njac_mat Df(x)dotV\nvec_jac barz^T Df(x)\nmat_jac barZ^T Df(x)","category":"page"},{"location":"#Second-Order","page":"Home","title":"Second-Order","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mode Formula\nhess D^2f(x)\nhess_vec D^2f(x) dotv\nhess_mat D^2f(x)  dotV\nvec_hess barz^T D^2f(x)\nmat_hess barZ^T D^2f(x)\nvechessvec barz^T D^2f(x)  dotv\nvechessmat barz^T D^2f(x)  dotV\nmathessmat barZ^T D^2f(x)  dotV\nmathessvec barZ^T D^2f(x)  dotv","category":"page"},{"location":"#Abs-Normal-Form","page":"Home","title":"Abs-Normal-Form","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mode Formula\nabs_norm Delta f(x)","category":"page"},{"location":"#Higher-Order","page":"Home","title":"Higher-Order","text":"","category":"section"},{"location":"#ADOLC-Format","page":"Home","title":"ADOLC-Format","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"fracpartial f(x)partial x","category":"page"},{"location":"#Partial-Format","page":"Home","title":"Partial-Format","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"fracpartial f(x)partial x","category":"page"},{"location":"#Seed-Space","page":"Home","title":"Seed-Space","text":"","category":"section"},{"location":"#Memory-handling","page":"Home","title":"Memory handling","text":"","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/reference.md\"]\nDepth = 1","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"reference]","category":"page"}]
}
