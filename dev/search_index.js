var documenterSearchIndex = {"docs":
[{"location":"lib/reference/#API-reference","page":"Reference","title":"API reference","text":"","category":"section"},{"location":"lib/reference/","page":"Reference","title":"Reference","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/reference/","page":"Reference","title":"Reference","text":"ADOLC.derivative\nADOLC.derivative!\nADOLC.tensor_address\nADOLC.partial_to_adolc_format\nADOLC.partial_to_adolc_format!\nADOLC.create_cxx_identity\nADOLC.create_partial_cxx_identity\nADOLC.seed_idxs_partial_format\nADOLC.seed_idxs_adolc_format\nADOLC.partial_format_to_seed_space\nADOLC.adolc_format_to_seed_space\nADOLC.create_independent\nADOLC.allocator\nADOLC.jl_allocator\nADOLC.cxx_res_to_jl_res!\nADOLC.cxx_res_to_jl_res\nADOLC.jl_res_to_cxx_res!\nADOLC.jl_res_to_cxx_res\nADOLC.array_types.CxxTensor\nADOLC.array_types.CxxVector\nADOLC.array_types.CxxMatrix\nADOLC.init_abs_normal_form\nADOLC.univariate_tpp\nADOLC.univariate_tpp!","category":"page"},{"location":"lib/reference/#ADOLC.derivative","page":"Reference","title":"ADOLC.derivative","text":"derivative(\n    f::Function,\n    x::Union{Cdouble,Vector{Cdouble}},\n    mode::Symbol;\n    dir::Union{Vector{Cdouble},Matrix{Cdouble}}=Vector{Cdouble}(),\n    weights::Union{Vector{Cdouble},Matrix{Cdouble}}=Vector{Cdouble}(),\n    tape_id::Integer=0,\n    reuse_tape::Bool=false,\n)\n\nA variant of the derivative driver, which can be used to compute first-order and second-order  derivatives, as well as the abs-normal-form  of the given function f at the point x. The available modes are listed here. The formulas in the tables define weights (left multiplier) and dir (right multiplier). Most modes leverage a tape, which has the identifier tape_id. If there is already a valid  tape for the function f at the selected point x use reuse_tape=true and set the tape_id accordingly to avoid the re-creation of the tape.\n\nExamples:\n\nFirst-Order:\n\nf(x) = sin(x)\nres = derivative(f, float(π), :jac)\n\n# output\n\n1-element CxxVector:\n -1.0\n\nSecond-Order:\n\nf(x) = [x[1]*x[2]^2, x[1]^2*x[3]^3]\nx = [1.0, 2.0, -1.0]\ndir = [1.0, 0.0, 0.0]\nweights = [1.0, 1.0]\nres = derivative(f, x, :vec_hess_vec, dir=dir, weights=weights)\n\n# output\n\n3-element CxxVector:\n -2.0\n  4.0\n  6.0\n\nAbs-Normal-Form:\n\nf(x) = max(x[1]*x[2], x[1]^2)\nx = [1.0, 1.0]\nres = derivative(f, x, :abs_normal)\n\n# output\n\nAbsNormalForm(0, 1, 2, 1, [1.0, 1.0], [1.0], [0.0], [0.0], [1.0], [1.5 0.5], [0.5;;], [1.0 -1.0], [0.0;;])\n\n\n\n\n\nderivative(\n    f::Function,\n    x::Union{Cdouble,Vector{Cdouble}},\n    param::Union{Cdouble,Vector{Cdouble}},\n    mode::Symbol;\n    dir=Vector{Cdouble}(),\n    weights=Vector{Cdouble}(),\n    tape_id::Integer=0,\n    reuse_tape::Bool=false,\n)\n\nThis version of the derivative driver allows the definition of function parameters (param), which can be changed  in subsequent calls without retaping. The given function f is expected to have the shape f(x, param).\n\nExample:\n\nfunction f(x, param)\n    x1 = x[1] * param[1]\n    return [x1*x[2], x[2]] \nend\nx = [-1.0, 1/2]\nparam = 3.0\ndir = [2.0, -2.0]\nres = derivative(f, x, param, :jac_vec, dir=dir, tape_id=1)\n\n##res[1] == 9.0\n##res[2] == -2.0\n\nparam = -3.0\nx = [1.0, 1.0]\nres = derivative(f, x, param, :jac_vec, dir=dir, tape_id=1, reuse_tape=true)\nres \n\n# output\n\n2-element CxxVector:\n  0.0\n -2.0\n\n\n\n\n\nderivative(\n    f::Function,\n    x::Union{Cdouble,Vector{Cdouble}},\n    partials::Vector{Vector{Int64}};\n    tape_id::Integer=0,\n    reuse_tape::Bool=false,\n    id_seed::Bool=false,\n    adolc_format::Bool=false,\n)\n\nA variant of the derivative driver, which can be used to compute higher-order derivatives of the function f  at the point x. The derivatives are specified as mixed-partials in the partials vector. To define the partial-derivatives use either the Partial-Format or the ADOLC-Format and set adolc_format accordingly. The flag id_seed is used to specify the method for seed-matrix generation. The underlying method leverages a tape, which has the identifier tape_id. If there is already a valid  tape for the function f at the selected point x use reuse_tape=true and set the tape_id accordingly to avoid the re-creation of the tape.\n\nExamples:\n\nPartial-Format:\n\nf(x) = [x[1]^2*x[2]^2, x[3]^2*x[4]^2]\nx = [1.0, 2.0, 3.0, 4.0]\npartials = [[1, 1, 0, 0], [0, 0, 1, 1], [2, 2, 0, 0]]\nres = derivative(f, x, partials)\n\n# output\n\n2×3 CxxMatrix:\n 8.0   0.0  4.0\n 0.0  48.0  0.0\n\nADOLC-Format:\n\nf(x) = [x[1]^2*x[2]^2, x[3]^2*x[4]^2]\nx = [1.0, 2.0, 3.0, 4.0]\npartials = [[2, 1, 0, 0], [4, 3, 0, 0], [2, 2, 1, 1]]\nres = derivative(f, x, partials, adolc_format=true)\n\n# output\n\n2×3 CxxMatrix:\n 8.0   0.0  4.0\n 0.0  48.0  0.0\n\n\n\n\n\nderivative(\n    f::Function,\n    x::Union{Cdouble,Vector{Cdouble}},\n    partials::Vector{Vector{Int64}},\n    seed::Matrix{Cdouble};\n    tape_id::Integer=0,\n    reuse_tape::Bool=false,\n    adolc_format::Bool=false,\n)\n\nVariant of the derivative driver for the computation of higher-order derivatives, that requires a seed. Details on the idea behind seed can be found  here.\n\nExample:\n\nf(x) = [x[1]^4, x[2]^3*x[1]]\nx = [1.0, 2.0]\npartials = [[1], [2], [3]]\nseed = CxxMatrix([[1.0, 1.0];;])\nres = derivative(f, x, partials, seed)\n\n\n# output\n\n2×3 CxxMatrix:\n  4.0  12.0  24.0\n 20.0  36.0  42.0\n\n\n\n\n\nderivative(\nf,\nx::Union{Cdouble, Vector{Cdouble}},\ndegree::Integer;\ntape_id::Integer=0,\nreuse_tape::Bool=false\n\n)\n\n\n\n\n\nderivative(\nf,\nx::Union{Cdouble, Vector{Cdouble}},\ndegree::Integer,\nseed::CxxMatrix;\ntape_id::Integer=0,\nreuse_tape::Bool=false\n\n)\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.derivative!","page":"Reference","title":"ADOLC.derivative!","text":"derivative!(\n    res,\n    f::Function,\n    m::Integer,\n    n::Integer,\n    x::Union{Cdouble,Vector{Cdouble}},\n    mode::Symbol;\n    dir::Union{Vector{Cdouble},Matrix{Cdouble}}=Vector{Cdouble}(),\n    weights::Union{Vector{Cdouble},Matrix{Cdouble}}=Vector{Cdouble}(),\n    tape_id::Integer=0,\n    reuse_tape::Bool=false,\n)\n\nA variant of the derivative driver for first-, second-order and abs-normal-form  computations that allows the user to provide a pre-allocated container for the result res. The container can be allocated by leveraging the methods allocator or init_abs_normal_form. In addition to the arguments of derivative, the output dimension m and  input dimension n of the function f is required. If there is already a valid  tape for the function f at the selected point x use reuse_tape=true and set the tape_id accordingly to avoid the re-creation of the tape.\n\nExample:\n\nf(x) = [cos(x[1]), x[2]*x[3]]\nx = [0.0, 1.5, -1.0]\nmode = :hess_mat\ndir = [[1.0, -1.0, 1.0] [0.5, -0.5, 1.0]]\nm = 2\nn = 3\nres =  allocator(m, n, mode, size(dir, 2)[1], 0)\nderivative!(res, f, m, n, x, mode, dir=dir)\nres\n# output\n\n2×3×2 CxxTensor:\n[:, :, 1] =\n -1.0  0.0   0.0\n  0.0  1.0  -1.0\n\n[:, :, 2] =\n -0.5  0.0   0.0\n  0.0  1.0  -0.5\n\nf(x) = max(x[1]*x[2], x[1]^2)\nx = [1.0, 1.0]\nm = 1\nn = 2\nabs_normal_form = init_abs_normal_form(f, x)\nderivative!(abs_normal_form, f, m, n, x, :abs_normal, tape_id=abs_normal_form.tape_id, reuse_tape=true)\nabs_normal_form\n# output\n\nAbsNormalForm(0, 1, 2, 1, [1.0, 1.0], [1.0], [0.0], [0.0], [1.0], [1.5 0.5], [0.5;;], [1.0 -1.0], [0.0;;])\n\n\n\n\n\nderivative!(\n    res,\n    f,\n    m::Integer,\n    n::Integer,\n    x::Union{Cdouble,Vector{Cdouble}},\n    partials::Vector{Vector{Int64}};\n    tape_id::Integer=0,\n    reuse_tape::Bool=false,\n    id_seed::Bool=false,\n    adolc_format::Bool=false,\n)\n\nA variant of the derivative driver for the computation of  higher-order derivatives that allows the user to provide  a pre-allocated container for the result res. In addition to the arguments of  derivative, the output dimension m and input dimension n of the function f is required. If there is already a valid tape for the function f at the  selected point x use reuse_tape=true and set the tape_id accordingly to  avoid the re-creation of the tape.\n\nExample: \n\nf(x) = x[1]^4*x[2]*x[3]*x[4]^2\nx = [3.0, -1.5, 1.5, -2.0]\npartials = [[4, 0, 0, 0], [3, 0, 1, 2]]\nm = 1\nn = 4\nres = CxxMatrix(m, length(partials))\nderivative!(res, f, m, n, x, partials)\nres\n\n# output\n\n1×2 CxxMatrix:\n -216.0  -216.0\n\n\n\n\n\nderivative!(\n    res,\n    f,\n    m::Integer,\n    n::Integer,\n    x::Union{Cdouble,Vector{Cdouble}},\n    partials::Vector{Vector{Int64}},\n    seed::CxxMatrix;\n    tape_id::Integer=0,\n    reuse_tape::Bool=false,\n    adolc_format::Bool=false,\n)\n\nVariant of the derivative! driver for the computation of higher-order derivatives, that requires a seed. Details on the idea behind seed can be found  here.\n\nExample:\n\nf(x) = [x[1]^4, x[2]^3*x[1]]\nx = [1.0, 2.0]\npartials = [[1], [2], [3]]\nseed = CxxMatrix([[1.0, 1.0];;])\nm = 2\nn = 2\nres = CxxMatrix(m, length(partials))\nderivative!(res, f, m, n, x, partials, seed)\nres\n\n# output\n\n2×3 CxxMatrix:\n  4.0  12.0  24.0\n 20.0  36.0  42.0\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.tensor_address","page":"Reference","title":"ADOLC.tensor_address","text":"tensor_address(degree::Integer, adolc_partial::Vector{Integer})\ntensor_address(degree::Integer, adolc_partial::Vector{Cint})\n\nGenerates the index (address) of the mixed-partial specified by adolc_partial in an higher-order derivative tensor of derivative order degree.\n\nnote: Note\nThe partial has to be in ADOLC-Format.\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.partial_to_adolc_format","page":"Reference","title":"ADOLC.partial_to_adolc_format","text":"partial_to_adolc_format(partial::Vector{I_1}, degree::I_2) where {I_1<:Integer, I_2<:Integer}\n\nTransforms a given partial to the ADOLC-Format. \n\nnote: Note\npartial is required to be in the Partial-format\n\nExample:\n\n\npartial = [1, 0, 4]\ndegree = sum(partial)\npartial_to_adolc_format(partial, degree)\n\n# output\n\n5-element Vector{Int32}:\n 3\n 3\n 3\n 3\n 1\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.partial_to_adolc_format!","page":"Reference","title":"ADOLC.partial_to_adolc_format!","text":"partial_to_adolc_format!(res::Vector{Cint}, partial::Vector{I_1}, degree::I_2) where {I_1<:Integer, I_2<:Integer}\npartial_to_adolc_format!(res::Vector{Cint}, partial::Vector{Cint}, degree::I) where I <: Integer\n\nVariant of partial_to_adolc_format that writes the result to res.\n\nExample:\n\npartial = [1, 3, 2, 0]\ndegree = sum(partial)\nres = zeros(Int32, degree)\npartial_to_adolc_format!(res, partial, degree)\n\n# output\n\n6-element Vector{Int32}:\n 3\n 3\n 2\n 2\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.create_cxx_identity","page":"Reference","title":"ADOLC.create_cxx_identity","text":"create_cxx_identity(n::I_1, m::I_2) where {I_1 <: Integer, I_2 <: Integer}\n\nCreates a identity matrix of shape (n, m) of type CxxPtr{CxxPtr{Float64}} (wrapper of C++'s double**).\n\nExample\n\nid = CxxMatrix(create_cxx_identity(2, 4), 2, 4)\n\n\n# output\n\n2×4 CxxMatrix:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.create_partial_cxx_identity","page":"Reference","title":"ADOLC.create_partial_cxx_identity","text":"create_partial_cxx_identity(n::I_1, idxs::Vector{I_2}) where {I_1 <: Integer, I_2 <: Integer}\n\nCreates a matrix of shape (n, length(idxs)) of type CxxPtr{CxxPtr{Float64}} (wrapper of C++'s double**). The columns are canonical basis vectors corresponding to the entries of idxs. The order of the basis vectors is defined by the order of the indices in idxs. Details about the application can be found in this guide.\n\nwarning: Warning\nThe number of rows n must be smaller than the maximal index of idxs!\n\nwarning: Warning\nThe values of idxs must be non-negative!\n\nExamples\n\nn = 4\nidxs = [1, 3]\nid = CxxMatrix(create_partial_cxx_identity(n, idxs), n, length(idxs))\n# output\n\n4×2 CxxMatrix:\n 1.0  0.0\n 0.0  0.0\n 0.0  1.0\n 0.0  0.0\n\nThe order in idxs defines the order of the basis vectors.\n\nn = 3\nidxs = [3, 0, 1]\nid = CxxMatrix(create_partial_cxx_identity(n, idxs), n, length(idxs))\n\n\n# output\n\n3×3 CxxMatrix:\n 0.0  0.0  1.0\n 0.0  0.0  0.0\n 1.0  0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.seed_idxs_partial_format","page":"Reference","title":"ADOLC.seed_idxs_partial_format","text":"seed_idxs_partial_format(partials::Vector{Vector{I}}) where I <: Integer\n\nExtracts the actually required derivative directions of partials and returns them  ascendet sorted. \n\nnote: Note\npartials has to be in Partial-Format.\n\nExample\n\n\npartials = [[1, 0, 0, 0, 3], [1, 0, 1, 0, 0], [0, 0, 3, 0, 0]]\nseed_idxs_partial_format(partials)\n\n# output\n\n3-element Vector{Int64}:\n 1\n 3\n 5\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.seed_idxs_adolc_format","page":"Reference","title":"ADOLC.seed_idxs_adolc_format","text":"seed_idxs_adolc_format(partials::Vector{Vector{I}}) where I <: Integer\n\nExtracts the actually required derivative directions of partials and returns them  ascendet sorted. \n\nnote: Note\npartials has to be in ADOLC-Format.\n\nExample\n\n\npartials = [[5, 5, 5, 1], [3, 1, 0, 0], [3, 3, 3, 0]]\nseed_idxs_adolc_format(partials)\n\n# output\n\n3-element Vector{Int64}:\n 1\n 3\n 5\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.partial_format_to_seed_space","page":"Reference","title":"ADOLC.partial_format_to_seed_space","text":"partial_format_to_seed_space(partials::Vector{Vector{I_1}}, seed_idxs::Vector{I_2}) where {I_1 <: Integer, I_2 <: Integer}\npartial_format_to_seed_space(partials::Vector{Vector{I}}) where I <: Integer\n\nConverts partials in Partial-Format to partials of the same format but with (possible) reduced number  of derivatives directions. The seed_idxs is expected to store the result of seed_idxs_partial_format(seed_idxs). Without seed_idxs the function first calls seed_idxs_partial_format(seed_idxs) to get the indices.\n\nExamples\n\n\npartials = [[0, 1, 1], [0, 2, 0]]\nseed_idxs = seed_idxs_partial_format(partials)\npartial_format_to_seed_space(partials, seed_idxs)\n\n# output\n\n2-element Vector{Vector{Int64}}:\n [1, 1]\n [2, 0]\n\nWithout seed_idxs\n\n\npartials = [[0, 1, 1], [0, 2, 0]]\npartial_format_to_seed_space(partials)\n\n# output\n\n2-element Vector{Vector{Int64}}:\n [1, 1]\n [2, 0]\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.adolc_format_to_seed_space","page":"Reference","title":"ADOLC.adolc_format_to_seed_space","text":"adolc_format_to_seed_space(partials::Vector{Vector{I_1}}, seed_idxs::Vector{I_2}) where {I_1 <: Integer, I_2 <: Integer}\nadolc_format_to_seed_space(partials::Vector{Vector{I}}) where I <: Integer\n\nSame as partial_format_to_seed_space but with ADOLC-Format.\n\nExamples\n\n\npartials = [[3, 2], [2, 2]]\nseed_idxs = seed_idxs_adolc_format(partials)\nadolc_format_to_seed_space(partials, seed_idxs)\n\n# output\n\n2-element Vector{Vector{Int64}}:\n [2, 1]\n [1, 1]\n\nWithout seed_idxs\n\n\npartials = [[3, 2], [2, 2]]\nseed_idxs = seed_idxs_adolc_format(partials)\nadolc_format_to_seed_space(partials, seed_idxs)\n\n# output\n\n2-element Vector{Vector{Int64}}:\n [2, 1]\n [1, 1]\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.create_independent","page":"Reference","title":"ADOLC.create_independent","text":"create_independent(x::Union{Cdouble, Vector{Cdouble}})\n\n\n\n\n\ncreate_independent(x::Union{Cdouble, Vector{Cdouble}}, param::Union{Cdouble,Vector{Cdouble}})\n\nThe entries in active describes the indices of the entries of x that are selected as the independant variables.  \n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.allocator","page":"Reference","title":"ADOLC.allocator","text":"allocator(m::Integer, n::Integer, mode::Symbol, num_dir::Integer, num_weights::Integer)\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.jl_allocator","page":"Reference","title":"ADOLC.jl_allocator","text":"jl_allocator(m::Int64, n::Int64, mode::Symbol, num_dir::Int64, num_weights::Int64)\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.array_types.cxx_res_to_jl_res!","page":"Reference","title":"ADOLC.array_types.cxx_res_to_jl_res!","text":"cxx_res_to_jl_res!(jl_res::AbstractVector{Cdouble}, cxx_res::CxxVector)\ncxx_res_to_jl_res!(jl_res::AbstractMatrix{Float64}, cxx_res::CxxMatrix)\ncxx_res_to_jl_res!(jl_res::AbstractArray{Float64, 3}, cxx_res::CxxTensor)\n\nCopies the entries of a CxxVector, CxxMatrix or CxxTensor  to a AbstractVector{Cdouble}, AbstractMatrix{Cdouble} or AbstractArray{Cdouble, 3}.\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.array_types.cxx_res_to_jl_res","page":"Reference","title":"ADOLC.array_types.cxx_res_to_jl_res","text":"cxx_res_to_jl_res(cxx_res::CxxVector) \ncxx_res_to_jl_res(cxx_res::CxxMatrix)\ncxx_res_to_jl_res(cxx_res::CxxTensor)\n\nCreates a Vector{Cdouble}, Matrix{Cdouble} or Array{Cdouble, 3} and copies the values from the given input CxxVector, CxxMatrix or CxxTensor to it.\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.array_types.jl_res_to_cxx_res!","page":"Reference","title":"ADOLC.array_types.jl_res_to_cxx_res!","text":"jl_res_to_cxx_res!(cxx_res::CxxVector, jl_res::AbstractVector{Cdouble}) \njl_res_to_cxx_res!(cxx_res::CxxMatrix, jl_res::AbstractMatrix{Cdouble})\njl_res_to_cxx_res!(cxx_res::CxxTensor, jl_res::AbstractArray{Cdouble, 3})\n\nCopies the values of a AbstractVector{Cdouble}, AbstractMatrix{Cdouble} or AbstractArray{Cdouble, 3} to a corresponding CxxVector, CxxMatrix or CxxTensor.\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.array_types.jl_res_to_cxx_res","page":"Reference","title":"ADOLC.array_types.jl_res_to_cxx_res","text":"jl_res_to_cxx_res(jl_res::AbstractVector{Cdouble}) \njl_res_to_cxx_res(jl_res::AbstractMatrix{Cdouble})\njl_res_to_cxx_res(jl_res::AbstractArray{Cdouble, 3})\n\nCreates a CxxVector, CxxMatrix or CxxTensor and copies the values from the given input AbstractVector{Cdouble}, AbstractMatrix{Cdouble} or AbstractArray{Cdouble, 3} to it.\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.array_types.CxxTensor","page":"Reference","title":"ADOLC.array_types.CxxTensor","text":"mutable struct CxxTensor <: AbstractArray{Cdouble, 3}\n\nWrapper for CxxPtr{CxxPtr{CxxPtr{Cdouble}}}, which is used as double*** in C++.\n\n\n\n\n\n","category":"type"},{"location":"lib/reference/#ADOLC.array_types.CxxVector","page":"Reference","title":"ADOLC.array_types.CxxVector","text":"mutable struct CxxVector <: AbstractVector{Cdouble}\n\nWrapper of a double* (CxxPtr{Cdouble}).\n\n\n\n\n\n","category":"type"},{"location":"lib/reference/#ADOLC.array_types.CxxMatrix","page":"Reference","title":"ADOLC.array_types.CxxMatrix","text":"mutable struct CxxMatrix <: AbstractMatrix{Cdouble}\n\nWrapper for CxxPtr{CxxPtr{Cdouble}}, which is used as double** in C++.\n\n\n\n\n\n","category":"type"},{"location":"lib/reference/#ADOLC.init_abs_normal_form","page":"Reference","title":"ADOLC.init_abs_normal_form","text":"init_abs_normal_form(\n    f, x::Union{Cdouble,Vector{Cdouble}}; tape_id::Integer=0, reuse_tape=false\n)\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.univariate_tpp","page":"Reference","title":"ADOLC.univariate_tpp","text":"univariate_tpp(\n    f,\n    x::Union{Cdouble,Vector{Cdouble}},\n    degree::Integer;\n    keep::Bool=false,\n    tape_id::Integer=0,\n    reuse_tape::Bool=false,\n)\n\nThe driver propagates univariate Taylor polynomials through the given function f at the point  x up to degree. The keep flag is used to prepare the tape for subsequent reverse-mode computations on the Taylor polynomial. The tape_id specifies the identifier of the tape and the flag reuse_tape should  be used for suppressing the tape creation. More information is given in the guide: Univariate Taylor Polynomial Propagation.\n\n\n\n\n\nunivariate_tpp(\n    f,\n    x::Union{Cdouble,Vector{Cdouble}},\n    degree::Integer,\n    init_tp::CxxMatrix;\n    keep::Bool=false,\n    tape_id::Integer=0,\n    reuse_tape::Bool=false,\n)\n\nVersion of the univariate_tpp driver, which allows additional control over the initial Taylor polynomial.  More information is given in the guide: Univariate Taylor Polynomial Propagation.\n\n\n\n\n\n","category":"function"},{"location":"lib/reference/#ADOLC.univariate_tpp!","page":"Reference","title":"ADOLC.univariate_tpp!","text":"univariate_tpp!(\n    res::CxxMatrix,\n    f,\n    x::Union{Cdouble,Vector{Cdouble}},\n    degree::Integer,\n    init_tp::CxxMatrix;\n    keep::Bool=false,\n    tape_id::Integer=0,\n    reuse_tape::Bool=false,\n)\n\nA version of the univariate_tpp driver that allows a user to pass in a pre-allocated CxxMatrix. More information is given in the guide: Univariate Taylor Polynomial Propagation.\n\n\n\n\n\n","category":"function"},{"location":"lib/wrapped_fcts/#List-of-wrapped-ADOL-C-drivers","page":"Wrapped Functions","title":"List of wrapped ADOL-C drivers","text":"","category":"section"},{"location":"lib/wrapped_fcts/#TbadoubleModule","page":"Wrapped Functions","title":"TbadoubleModule","text":"","category":"section"},{"location":"lib/wrapped_fcts/","page":"Wrapped Functions","title":"Wrapped Functions","text":"getValue\ngradient\njacobian\nhessian\nvec_jac\njac_vec\nhess_vec\nhess_mat\nlagra_hess_vec\njac_solv\n\nad_forward(short tag, int m, int n, int d, int keep, double **X, double **Y) (in ADOL-C: forward)\nad_reverse(short tag, int m, int n, int d, double *u, double **Z) (in ADOL-C: reverse)\n\nzos_forward\nfos_forward\nhos_forward\nhov_wk_forward\n\nfov_forward\nhov_forward\n\nfos_reverse\nhos_reverse\n\nfov_reverse\nhov_reverse\ntensor_address\ntensor_eval","category":"page"},{"location":"lib/wrapped_fcts/#Abs-Smooth-Utilities","page":"Wrapped Functions","title":"Abs-Smooth Utilities","text":"","category":"section"},{"location":"lib/wrapped_fcts/","page":"Wrapped Functions","title":"Wrapped Functions","text":"enableMinMaxUsingAbs\nget_num_switches\nzos_pl_forward\nfos_pl_forward\nfov_pl_forward\nabs_normal","category":"page"},{"location":"lib/wrapped_fcts/#Tape-Utilities","page":"Wrapped Functions","title":"Tape Utilities","text":"","category":"section"},{"location":"lib/wrapped_fcts/","page":"Wrapped Functions","title":"Wrapped Functions","text":"<< (in ADOL-C: <<=)\n>> (in ADOL-C: =>>)\ntrace_on(int tag)\ntrace_on(int tag, int keep)\ntrace_off(int file)\ntrace_off()","category":"page"},{"location":"lib/wrapped_fcts/#TladoubleModule","page":"Wrapped Functions","title":"TladoubleModule","text":"","category":"section"},{"location":"lib/wrapped_fcts/","page":"Wrapped Functions","title":"Wrapped Functions","text":"setNumDir(int const &n) \ngetValue()                      \ngetADValue(int const &i)\nsetADValue(double const &val)\nsetADValue(double const val, int const &i)","category":"page"},{"location":"lib/wrapped_fcts/#Arithmethics","page":"Wrapped Functions","title":"Arithmethics","text":"","category":"section"},{"location":"lib/wrapped_fcts/","page":"Wrapped Functions","title":"Wrapped Functions","text":"+ \n- \n* \n/ \n^","category":"page"},{"location":"lib/wrapped_fcts/#Comparison","page":"Wrapped Functions","title":"Comparison","text":"","category":"section"},{"location":"lib/wrapped_fcts/","page":"Wrapped Functions","title":"Wrapped Functions","text":"<\n>\n>=\n<=\n==","category":"page"},{"location":"lib/wrapped_fcts/#Unary-Functions","page":"Wrapped Functions","title":"Unary Functions","text":"","category":"section"},{"location":"lib/wrapped_fcts/","page":"Wrapped Functions","title":"Wrapped Functions","text":"abs\nsqrt\nsin\ncos\ntan\nasin\nacos\natan\nexp\nlog\nlog10\nsinh\ncosh\ntanh\nasinh\nacosh\natanh\nceil\nfloor\nmax\nmin\nldexp\nfrexp\nerf\ncbrt","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"DocTestSetup = quote\n    using ADOLC\nend","category":"page"},{"location":"lib/guides/utpp/#Univariate-Taylor-Polynomial-Propagation","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"","category":"section"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"The univariate Taylor polynomial propagation (UTPP) aims to compute the univariate Taylor polynomial (UTP) varphi_f of a function f and is given as a polynomial in t in mathbbR:","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"varphi_f(t) = sum_i=0^d f^i(x)t^i","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"where d in mathbbN is the maximal order or degree and x in mathbbR^n the evaluation point of the UTP. f^i(x) defines the i-th uniariate Taylor coefficient (UTC):","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"f^i(x) = sum_undersetk=ik in mathbbN^n frac1kfracpartial^k f(x)partial^k x","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"Since the UTP is computed component-wise (w.r.t the output of f), it is usually assumed f has a one dimensional output. ","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"To compute the polynomial, UTPP leverages so-called recurrence relations. Recurrence relations are formulas specifying the UTC. For example: \nLet n=2, f(x) = x_1 + x_2 and h and g suitable functions. The recurrence relation for the i-th UTC of f up to degree d=2 is given by","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"f^i(x) = h^i(x) + g^i(x)","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"Therefore, if we know the UTPs of h and g we can conclude the UTP of f. These kind of formulas motivate the term \"propagation\" of input polynomials. Various recurrence relations can be found in table 13.1 and 13.2 of [2]. AD packages implement the recurrence relations for a set of elemental functions. If a user-defined function is decomposable into these elemental functions, the AD package can computes the UTP automatically.  ","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"ADOLC.jl leverages ADOL-C's utilities for UTPP and wraps it in the univariate_tpp driver, which allows the easy computation of Taylor polynomials of functions with arbitrary input and output dimension. To demonstrate the application of univariate_tpp, lets go back to the example. If we set n = 2 and h(x) = sin(x_1), g(x) = x_2 for all x=(x_1 x_2) in mathbbR^2, we have by definition of the UTC","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"f^0(x) = h^0(x) + g^0(x) = sin(x_1) + x_2 \nf^1(x) = h^1(x) + g^1(x) = cos(x_1)x_1 + x_2 \nf^2(x) = frac12left(-sin(x_1)(x_1)^2 + cos(x_1)x_1right) + frac12x_2","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"The formulas above emphasize that the values of x_i and x_i must be given. Intuitively one could set them to the derivatives of the projections by interpreting x_i = p_i(x). Then x_i = 1 and all further derivatives are zero. However, the input values x_i could be generated from a complex computation. A user may wants to include the derivative information of this computation in x_i x_i dots. To this end, ADOL-C allows a user to provide distinct input UTC for each input variable x_i, where the evaluation point is one dimensional. Those UTC have the form:","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"sum_j=0^d y^j t^j","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"The coefficients y^j are user-given, which means we need d+1 coefficients for every input variable x_i. If the UTC above corresponds to the input variable x_1, internally the following connection between the coefficient y^i and the i-th derivative of x_1 is expected","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"y^i = frac1ix_1^(i)","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"Here it is assumed that x_1 is provided by some function, which makes sense of the derivative. The output of univariate_tpp are the UTC of f's UTP. \nIn our example, lets first set the input UTCs corresponding to the UTP of the projections p_i(x) = x_i. For x_1 we get y^0 = x_1, y^1 = 1 and y^2 = 0. Similarly for x_2. If we further choose x = (fracpi2 frac12) we can compute the UTCs f^0, f^1 and f^2 of f with ADOLC.jl easily:","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"f(x) = sin(x[1]) + x[2]\nx = [pi / 2, 0.5]\nd = 2\nutp = univariate_tpp(f, x, 2)\n\n# output\n\n1×3 CxxMatrix:\n 1.5  1.0  -0.5","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"note: Note\nThe initialization with the input UTP based on the projections is done automatically if no other initialization UTP is provided to the parameter init_tp.","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"Next, we comput the UTP at the same evaluation point x = (fracpi2 frac12), but now x_2 is obtained from the function x_2(s) = s^2 + 3s + frac12, while x_1 is still determined by the projection p_1. Then, x_2(0) = frac12, x_2(0) = 3 and x_2(0) = 2. The corresponding UTCs are given as y^0 = frac12, y^1 = 3 and y^2 = 1. The input UTCs are now written to the parameter init_tp of univariate_tpp. The UTCs of f are again easily computed:","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"f(x) = sin(x[1]) + x[2]\nx = [pi / 2, 0.5]\nd = 2\ninit_tp = CxxMatrix([[pi /2, 0.5] [1.0, 3.0] [0.0, 1.0]])\nutp = univariate_tpp(f, x, d, init_tp)\n\n# output\n\n1×3 CxxMatrix:\n 1.5  3.0  0.5","category":"page"},{"location":"lib/guides/utpp/","page":"Univariate Taylor Polynomial Propagation","title":"Univariate Taylor Polynomial Propagation","text":"For more information on univariate Taylor polynomial propagation I recommend to read the Chapter 13.2 \"Taylor Polynomial Propagation\" from [2].","category":"page"},{"location":"lib/derivative_modes/#Derivative-Modes","page":"Derivative Modes","title":"Derivative Modes","text":"","category":"section"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"The following sections provide some details about the available modes and possibilities for the computation of derivatives with derivative or derivative!.","category":"page"},{"location":"lib/derivative_modes/#First-Order","page":"Derivative Modes","title":"First-Order","text":"","category":"section"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"A list of the available modes for first-order derivative computation using derivative or derivative! is presented below.  ","category":"page"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"Mode Formula Output Space\n:jac Df(x) mathbbR^m times n\n:jac_vec Df(x)dotv mathbbR^m\n:jac_mat Df(x)dotV mathbbR^m times p\n:vec_jac barz^T Df(x) mathbbR^n\n:mat_jac barZ^T Df(x) mathbbR^q times n","category":"page"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"Each mode's formula symbolizes the underlying computation. A user can read-off the dimension of the result from the last column, where it is assumed that fmathbbR^n to mathbbR^m, dotv in mathbbR^n, dotV in mathbbR^n times p, barz  in mathbbR^m and barZ in mathbbR^m times q.","category":"page"},{"location":"lib/derivative_modes/#Second-Order","page":"Derivative Modes","title":"Second-Order","text":"","category":"section"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"A list of the available modes for second-order derivative computation using derivative or derivative! is presented below.  ","category":"page"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"Mode Formula Output Space\n:hess D^2f(x) mathbbR^m times n times n\n:hess_vec D^2f(x) dotv mathbbR^m times n\n:hess_mat D^2f(x)  dotV mathbbR^m times n times p\n:vec_hess barz^T D^2f(x) mathbbR^n times n\n:mat_hess barZ^T D^2f(x) mathbbR^q times n times n\n:vec_hess_vec barz^T D^2f(x)  dotv mathbbR^n\n:vec_hess_mat barz^T D^2f(x)  dotV mathbbR^n times p\n:mat_hess_mat barZ^T D^2f(x)  dotV mathbbR^q times n times p\n:mat_hess_vec barZ^T D^2f(x)  dotv mathbbR^q times n","category":"page"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"Each mode's formula symbolizes the underlying computation. A user can read-off the dimension of the result from the last column, where it is assumed that fmathbbR^n to mathbbR^m, dotv in mathbbR^n, dotV in mathbbR^n times p, barz  in mathbbR^m and barZ in mathbbR^m times q.","category":"page"},{"location":"lib/derivative_modes/#Abs-Normal-Form","page":"Derivative Modes","title":"Abs-Normal-Form","text":"","category":"section"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"There is one mode to compute the abs-normal-form of a function using derivative or derivative!:","category":"page"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"Mode Formula\n:abs_norm Delta f(x)","category":"page"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"The theory behind this method can be found in [3].","category":"page"},{"location":"lib/derivative_modes/#Higher-Order","page":"Derivative Modes","title":"Higher-Order","text":"","category":"section"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"The goal of the following explanations is to familiarize the reader with  the possibilities for computing higher-order derivatives that are included in ADOLC.jl. In the context of ADOLC.jl, requested higher-order derivatives are collected in a Vector of  arbitrary-order mixed-partials. For example, let fmathbbR^n to mathbbR^m and we want to compute the partials","category":"page"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"leftfracpartial^3partial^2 f(x)partial^3 x_2 partial^2 x_1 fracpartial^4 f(x)partial^4 x_3 fracpartial^2 f(x)partial^2 x_1right","category":"page"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"leveraging the derivative (derivative!) driver. After defining the function f and the point for the derivative evaluation x, we have to select the format of the partials. There are two options that describe a partial derivative as a  Vector{Int64}.","category":"page"},{"location":"lib/derivative_modes/#ADOLC-Format","page":"Derivative Modes","title":"ADOLC-Format","text":"","category":"section"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"The ADOLC-Format repeats the index i of a derivative direction x_i up to the derivative order of this index: fracpartial^4 f(x)partial^4 x_3 to 3 3 3 3. Additionally, the resulting vector is sorted descendent; if the vector's length is less than the total derivative degree, it is filled with zeros. Thus, the requested partials are given by","category":"page"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"\n 2 2 2 1 1\n 3 3 3 3 0\n 1 1 0 0 0\n","category":"page"},{"location":"lib/derivative_modes/#Partial-Format","page":"Derivative Modes","title":"Partial-Format","text":"","category":"section"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"The Partial-Format leverages a more natural scheme to define the mixed-partial. The entry of a partial at index i is the derivative degree corresponding to the derivative direction x_i. Therefore, partials is given as","category":"page"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"\n 2 3 0 0\n 0 0 4 0\n 2 0 0 0\n","category":"page"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"note: Note\nInternally, there is, at some point, a conversion from Partial-Format to ADOLC-Format since the access to the higher-order tensor computed with ADOL-C is based on the ADOLC-Format. However, only one entry is converted at a time, meaning that the benefits of both modes, as explained below, are still valid.","category":"page"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"note: Note\nBoth formats have their benefits. The ADOLC-Format should be used if the total derivative degree is small compared to the number of independents n. Otherwise, Partial-Format should be used.","category":"page"},{"location":"lib/derivative_modes/","page":"Derivative Modes","title":"Derivative Modes","text":"There are utilities to convert between the formats: partial_to_adolc_format","category":"page"},{"location":"lib/guides/seed_matrix/","page":"Seed Matrix","title":"Seed Matrix","text":"DocTestSetup = quote\n    using ADOLC\nend","category":"page"},{"location":"lib/guides/seed_matrix/#Seed-Matrix","page":"Seed Matrix","title":"Seed-Matrix","text":"","category":"section"},{"location":"lib/guides/seed_matrix/","page":"Seed Matrix","title":"Seed Matrix","text":"This guide is related to the higher-order derivative computation with  derivative or derivative!. Internally, the drivers are based on the propagation of univariate Taylor polynomials [1]. The underlying method leverages a seed matrix Sin mathbbR^n times p to compute mixed-partials of arbitrary order for a function fmathbbR^n to mathbbR^m in the form: ","category":"page"},{"location":"lib/guides/seed_matrix/","page":"Seed Matrix","title":"Seed Matrix","text":"    fracpartial^k f(x + Sz)partial^k zbig_z=0 ","category":"page"},{"location":"lib/guides/seed_matrix/","page":"Seed Matrix","title":"Seed Matrix","text":"for some z in mathbbR^p. Usually, S is the identity or the partial identity (see create_partial_cxx_identity), which is also the case, when no seed is passed to the driver. To switch between both identity options the flag id_seed can be used. In the case of identity, the formula above boils down to ","category":"page"},{"location":"lib/guides/seed_matrix/","page":"Seed Matrix","title":"Seed Matrix","text":"    fracpartial^k f(x + Sz)partial^k zbig_z=0= fracpartial^k f(x)partial^k x","category":"page"},{"location":"lib/guides/seed_matrix/","page":"Seed Matrix","title":"Seed Matrix","text":"Moreover, the partial identity results in the same but is more efficient. Leveraging the partial identity ensures that only the derivatives of the requested derivative directions are computed, and this is explained briefly in the following paragraph.   ","category":"page"},{"location":"lib/guides/seed_matrix/","page":"Seed Matrix","title":"Seed Matrix","text":"Assume we want to compute the derivatives specified in the Partial-Format: [[4, 0, 0, 3], [2, 0, 0, 4], [1, 0, 0, 1]].   Obviously, none of the derivatives includes x_2 and x_3. To avoid unnecessary computations (i.e., the propagation of unnecessary univariate Polynomials), the partial identity is created, stacking only those canonical basis vectors that are related to the requested derivative directions. In our case, the partial identity looks like this:  ","category":"page"},{"location":"lib/guides/seed_matrix/","page":"Seed Matrix","title":"Seed Matrix","text":"left\n    beginmatrix\n    1  0 \n    0  0 \n    0  0 \n    0  1 \n    endmatrix\n right","category":"page"},{"location":"lib/guides/seed_matrix/","page":"Seed Matrix","title":"Seed Matrix","text":"As you can see, the directions are reduced from four to two. In general, the number of required univariate Polynomial propagations to compute all mixed-partials up to degree d of for f is left( beginmatrix n - 1 + d  d endmatrix right). Leveraging the seed S reduces this number to left( beginmatrix p - 1 + d  d endmatrix right), where p is often much smaller than n. In addition, S can be used as a subspace projection. For example, if S=1 dots 1^T, you could compute the sum of the different univariate Taylor coefficients:","category":"page"},{"location":"lib/guides/seed_matrix/","page":"Seed Matrix","title":"Seed Matrix","text":"using ADOLC\nf(x) = x[1]^3*x[2]^2 - x[2]^3\nx = [1.0, 1.0]\npartials = [[1], [2], [3]]\nseed = CxxMatrix([[1.0, 1.0];;])\nres = derivative(f, x, partials, seed)\n\n# output\n\n1×3 CxxMatrix:\n 2.0  14.0  54.0","category":"page"},{"location":"lib/guides/ww_cxx_mem/","page":"Working with C++ Memory","title":"Working with C++ Memory","text":"DocTestSetup = quote\n    using ADOLC\nend","category":"page"},{"location":"lib/guides/ww_cxx_mem/#Working-with-C-Memory","page":"Working with C++ Memory","title":"Working with C++ Memory","text":"","category":"section"},{"location":"lib/guides/ww_cxx_mem/","page":"Working with C++ Memory","title":"Working with C++ Memory","text":"ADOLC.jl is a wrapper of the C/C++ library ADOL-C. Wrapper means data from Julia is passed to C++, and calls to functions in Julia trigger C++ function calls to get output data in Julia. The communication between Julia and ADOL-C is handled by CxxWrap.jl, which, for example, allows to pass a Cint from Julia into a int in C++ automatically. Most functions  of ADOL-C modify pre-allocated memory declared as double*, double**, or double*** to store a functions' results. Two apparent options exist for providing the pre-allocated data to the C++ functions called from Julia. The first option would be to write wrappers in C++, which allocate the memory every time before the actual ADOL-C function call. This would cease control over the allocations from Julia, but it would be easier to work with on the Julia side, and the C++ side would have full control over the memory. The second option is to allocate  C++-owned data from Julia by calling ADOL-C's allocation methods from Julia. This data is then passed from Julia to ADOL-C's functions which mutates the allocated data, and access the mutated values from Julia. The second option allows more control over the data, but a user has to be aware of some critical aspects: ","category":"page"},{"location":"lib/guides/ww_cxx_mem/","page":"Working with C++ Memory","title":"Working with C++ Memory","text":"C++ owned memory is not automatically garbage collected and can lead to memory leaks quickly if not released. For example, having a Julia function that allocates a double** in C++ and binds this pointer to a variable in a Julia would release the  bound variable when going out of the functions' scope, but the C++ memory would still be  there, you just cannot access it anymore.\nThere is no out-of-bounds error checking to prevent accessing or setting of  data outside of the allocated area, which may lead to segmentation faults and program crashes.\nIf you want to do computations with the C++ data, you either have to copy these to a corresponding Julia type or write access  methods to work with the C++  allocated data.","category":"page"},{"location":"lib/guides/ww_cxx_mem/","page":"Working with C++ Memory","title":"Working with C++ Memory","text":"ADOLC.jl implements the second option and wrapps the C++ memory in a mutable struct in Julia: There are three types CxxVector, CxxMatrix and CxxTensor. The first critical aspect is avoided by attaching the structs with a finalizer allowing Julia's garbage collector to release the C++ owned memory. We implement the usual utilities for Array-data to handle the access and tackle the second critical aspect. Since these types are subtypes of AbstractVector{Cdouble}, AbstractMatrix{Cdouble} and AbstractArray{Cdouble, 3} you can work with them like corresponding Julia data. Therefore, point three is also avoided.  The intended use-case of the wrapper types is shown below.","category":"page"},{"location":"lib/guides/ww_cxx_mem/","page":"Working with C++ Memory","title":"Working with C++ Memory","text":"The derivative! driver requires a pre-allocated CxxVector, CxxMatrix or CxxTensor. For first- and second-order computations the problem-specific allocation is done using allocator. This function allocates the wrapped C++ memory for your specific case (i.e., for the problem-specific parameters m, n, mode, num_dir, num_weights). For example:","category":"page"},{"location":"lib/guides/ww_cxx_mem/","page":"Working with C++ Memory","title":"Working with C++ Memory","text":"using ADOLC # hide\nf(x) = (x[1] - x[2])^2\nx = [3.0, 7.5]\ndir = [1/3, 1/7]\nm = 1\nn = 2\nmode = :jac_vec\nnum_dir = size(dir, 2)[1]\nnum_weights = 0\ncxx_res = allocator(m, n, mode, num_dir, num_weights)\nderivative!(cxx_res, f, m, n, x, mode, dir=dir)","category":"page"},{"location":"lib/guides/ww_cxx_mem/","page":"Working with C++ Memory","title":"Working with C++ Memory","text":"For higher-order derivatives one has to allocate res as CxxMatrix:","category":"page"},{"location":"lib/guides/ww_cxx_mem/","page":"Working with C++ Memory","title":"Working with C++ Memory","text":"using ADOLC # hide\nf(x) = [x[1]^4, x[2]^3*x[1]]\nx = [1.0, 2.0]\npartials = [[1], [2], [3]]\nseed = CxxMatrix([[1.0, 1.0];;])\nm = 2\nn = 2\nres = CxxMatrix(m, length(partials))\nderivative!(res, f, m, n, x, partials, seed)\nres","category":"page"},{"location":"lib/guides/ww_cxx_mem/","page":"Working with C++ Memory","title":"Working with C++ Memory","text":"If you really need the Julia types Vector{Cdouble}, Matrix{Cdouble} or AbstractArray{Cdouble, 3} feel free to use jl_allocator and cxx_res_to_jl_res!( or cxx_res_to_jl_res):","category":"page"},{"location":"lib/guides/ww_cxx_mem/","page":"Working with C++ Memory","title":"Working with C++ Memory","text":"using ADOLC # hide\nf(x) = (x[1] - x[2])^2\nx = [3.0, 7.5]\ndir = [1/3, 1/7]\nm = 1\nn = 2\nmode = :jac_vec\nnum_dir = size(dir, 2)[1]\nnum_weights = 0\ncxx_res = allocator(m, n, mode, num_dir, num_weights)\njl_res = jl_allocator(m, n, mode, num_dir, num_weights)\nderivative!(cxx_res, f, m, n, x, mode, dir=dir)\n\n# conversion \ncxx_res_to_jl_res!(jl_res, cxx_res)\n","category":"page"},{"location":"lib/guides/performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"DocTestSetup = quote\n    using ADOLC\nend","category":"page"},{"location":"lib/guides/performance_tips/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"lib/guides/performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"The following tips are meant to decrease the derivative computation's runtime complexity, especially when derivatives of the same function are needed repeatedly. There are two major modifications for all kinds of derivatives: ","category":"page"},{"location":"lib/guides/performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"Use the derivative! driver, and work with allocator as explained in the guide Working with C++ Memory\nReuse the tape as often as possible. derivative! (derivative) supply the flag reuse_tape, which if set to true suppresses the creation of the tape, in addition the identifiyer of an existing tape must be provided as the parameter tape_id. More details can be found here.","category":"page"},{"location":"lib/guides/performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"An example could look like this:","category":"page"},{"location":"lib/guides/performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"using ADOLC # hide \n\n# problem setup\nf(x) = (x[1] - x[2])^2\nx = [3.0, 7.5]\ndir = [1/3, 1/7]\nm = 1\nn = 2\nmode = :jac_vec\nnum_dir = size(dir, 2)[1]\nnum_weights = 0\ntape_id = 1\nnum_iters = 100\n\n# pre-allocation \ncxx_res = allocator(m, n, mode, num_dir, num_weights)\n\nderivative!(cxx_res, f, m, n, x, mode, dir=dir, tape_id=tape_id)\n\n# conversion \n\n# do computations ....\n\nfor i in 1:num_iters\n    # update x ...\n    derivative!(cxx_res, f, m, n, x, mode, dir=dir, tape_id=tape_id, reuse_tape=true)\n    # do computations ... \nend","category":"page"},{"location":"lib/guides/performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"Moreover, for higher-order derivatives you might consider the generation of a seed. However, if you do not pass a seed to the derivative! (derivative) driver, the partial identity is created as the seed automatically (see here). ","category":"page"},{"location":"#ADOLC.jl","page":"Home","title":"ADOLC.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia wrapper of the automatic differentiation package ADOL-C","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using ADOLC\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"To add this package, use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"ADOLC\")\nusing ADOLC","category":"page"},{"location":"","page":"Home","title":"Home","text":"First- and second-order derivatives can be calculated as follows","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x) = [x[1]*x[2]^2, x[1]^2*x[3]^3]\nx = [1.0, 2.0, -1.0]\ndir = [1.0, 0.0, 0.0]\nweights = [1.0, 1.0]\nres = derivative(f, x, :vec_hess_vec, dir=dir, weights=weights)\n\n# output\n\n3-element CxxVector:\n -2.0\n  4.0\n  6.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are various available modes for first- and second-order calculations. The computation of higher-order derivatives is explained here and works as sketched below","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x) = [x[1]^2*x[2]^2, x[3]^2*x[4]^2]\nx = [1.0, 2.0, 3.0, 4.0]\npartials = [[1, 1, 0, 0], [0, 0, 1, 1], [2, 2, 0, 0]]\nres = derivative(f, x, partials)\n\n# output\n\n2×3 CxxMatrix:\n 8.0   0.0  4.0\n 0.0  48.0  0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"For advanced users, there is a list of all functions, wrapped from ADOL-C.","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/reference.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"A. Griewank, J. Utke and A. Walther. Evaluating higher derivative tensors by forward propagation of univariate Taylor series. Mathematics of Computation 69 (1999).\n\n\n\nA. Griewank and A. Walther. 13. Taylor and Tensor Coefficients. In: Evaluating Derivatives (Society for Industrial and Applied Mathematics, 2008).\n\n\n\nA. Griewank. On stable piecewise linearization and generalized algorithmic differentiation. Optimization Methods and Software 28 (2013).\n\n\n\n","category":"page"},{"location":"lib/guides/tape_management/","page":"Tape Management","title":"Tape Management","text":"DocTestSetup = quote\n    using ADOLC\nend","category":"page"},{"location":"lib/guides/tape_management/#Tape-Management","page":"Tape Management","title":"Tape Management","text":"","category":"section"},{"location":"lib/guides/tape_management/","page":"Tape Management","title":"Tape Management","text":"ADOL-C (and therefore ADOLC.jl) leverages a tape for its  derivative calculations except for its tape-less forward-mode, which is applied to compute Jacobians for certain inputs. The tape's task is to save information of all operations in which ADOL-C's derivative types are involved, and the connection to other  operations. Thus, the tape represents a variant of the computational graph of the user-defined function f at a given point x. The stored information is used for univariate Taylor polynomial propagation computing higher-order derivatives, and for the application of the reverse-mode in first- and second-order calculations. Since the tape only stores the calling sequence for the first given input point x, a derivative computation based on the tape could lead to wrong results for other input points. However, the tape's construction is expensive, making it beneficial to create the tape only once and  recreate it if the computational graph of f changes. For example, changes in the computational graph of the f might occur if the function is composed of several if-statements. In most cases, ADOL-C stops the program with an error whenever the tape has to be recreated for a new input. In ADOLC.jl, the derivative (derivative!) driver builds the tape automatically. Users can set the resue_tape flag to suppress this build process. In the first call to the driver, the tape identifier tape_id has to be specified. In the following calls of derivative (derivative!), set the flag reuse_tape to true and pass the identifier again. As demonstrated in the following example, the application is straightforward.","category":"page"},{"location":"lib/guides/tape_management/","page":"Tape Management","title":"Tape Management","text":"using ADOLC # hide \nf(x) = 1x[1]*x[2]^2 - x[3]^3\nx = [-1.5, 1.0, -1.5]\ndir = [0.0, 0.0, -1.0]\nmode = :hess_vec\ntape_id = 0\nnum_iters = 99\nres0 = derivative(f, x, mode, dir=dir, tape_id=tape_id)\n# update x ....\nfor i in 1:num_iters\n    res = derivative(f, x, mode, dir=dir, tape_id=tape_id, reuse_tape=true)\n    # do computations ....\nend","category":"page"}]
}
